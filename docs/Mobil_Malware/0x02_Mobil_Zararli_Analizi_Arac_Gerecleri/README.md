# 0x02 | Mobil Zararlı Analizi Araç Gereçleri Notları by @ebubekirtrkr

[Mobil Zararlı Analizi Bölüm 1 Ortamı Kuralım | eybisi.run](https://eybisi.run/Mobil-Zararli-Analizi-Bolum-1-Ortami-Kuralim)

Yukarıda linki paylaşılan yazıya ek olarak alınmış notlarımdır.

Genymotion'u ve sanal makinenizi yükledikten sonra, [Mobil Zararlı Analizi - Files](https://drive.google.com/drive/u/0/folders/1azAtKQNv476LzxJjN60jRGz7MWNkVWj7)
linkindeki dosyaları belirttiğim sırayla emulatöre sürükleyip bırakabilirsiniz.

## Genel Notlar
1. Android 6.0 kullanmamızın nedenlerinden birisi, daha yüksek android sürümleri user level sertifikaları kabul etmemekte. Dolayısıyla araya burp'u sokamıyoruz.
2. Uygulamada SSLPinning varsa Burp Suite de uyarı görürsünüz.
3. SSLPinning diye bir sorunla karşılaşınca yapılabilecekler.
   1. Xposed sslunpinng modülü [mobi.acpm.sslunpinning](https://repo.xposed.info/module/mobi.acpm.sslunpinning)
   2. frida ssl unpinning [universal-android-ssl-pinning-bypass](https://github.com/httptoolkit/frida-interception-and-unpinning)
   3. apktool ile decompile edip sslpinnig fonksiyonunu silip tekrar compile etmek
4. jadx de ilk olarak `http://` yada `https://` aratmak, zararlının gönderdiği istekleri yakalamaktaki büyük adımlardan biri.
5. burp un yakalayamadığı, layer 4 daki istekleri `adb shell tcpdump` ile yakalayabilirsiniz
6. python daki `androguard` ile otomatik analiz yapabiliriz.
7. analiz edecek uygulama bulmak için : [Koodous](https://koodous.com/)
8. Xposed sistem seviyesinde hooklama yapıyor, frida ise uygulama seviyesinde, Yani SSLpinning gibi her uygulama için gerekli olabilecek şeyleri Xposed ile,
daha uygulama özelindeki şeyleri ise frida ile uygulayabilirsiniz.
9. Android studio nun sanal makinesini command line dan `-no-window` komutu ile çalıştırmak, otomatize toollarda işe yarayabilir.
10. Genymotion da sms simule edilebiliyor


## adb (Android Debug Bridge)
adb, cihazınızla iletişim kurmayı sağlayan çok yönlü bir komut satırı aracıdır.
Bu aracı kullanmak için android'de usb hata ayıklamayı açmanız gerekmekte.

### Bazı komutlar

`adb devices` : bağlı tüm cihazları listeler

`adb logcat` : uygulamaların android cihazda yazdırdıkları logları okur.

`adb shell` : cihaz içinde bir shell açar.

`adb shell pm list packages` : cihazda olan paketlerin ID'lerini listeler.

`adb shell pm path <paketID>` : `<paketID>` ID'sine sahip uygulamanın apk yolunu dönderir.

`adb pull <kaynak> <hedef>` : `<kaynak>` 'daki dosyayı/klasörü bilgisayardaki `<hedef>` e çekmenizi sağlar.

`adb push <kaynak> <hedef>` : `<kaynak>` 'daki dosyayı/klasörü,  cihazdaki `<hedef>` e atmanızı sağlar.

`adb install <paket>.apk` : `<paket.apk>` yi cihaza yüklemenizi sağlar

`adb uninstall <paketID>` : `<paketID>` ID'sine sahip uygulamayı cihazdan kaldırır.


şu komut kombinasyonuyla  uygulama apksını hızlıca telefondan alabilirsiniz.
```bash
adb shell pm list packages # çekilecek paketin idsini alalım

adb shell pm path <paketID> # Idsini aldığımız paketin apk yolunu alalım.

adb pull <hedef> # apk yolunu aldığımız paketi apk olarak pcye çekelim
```

[ADB | developer.android](https://developer.android.com/studio/command-line/adb)

[How to install | xda-developers ](https://www.xda-developers.com/install-adb-windows-macos-linux/)

## scrcpy

Bu tool sayesinde telefonunuzu adb ile bilgisayara bağlayıp, yönetebilirsiniz.

Ayrıca Wireless üzerinden de bağlanmanız mümkün.
Önce usbnizi bağlayın.
1. `adb tcpip 5555` komutu ile adb'yi TCP/IP üzerinde etkinleştirin.
2. Cihazınızın kablo bağlantısını kesin.
3. `adb connect DEVICE_IP:5555` ile cihazınıza bağlanın.
4. scrcpy'yi çalıştırın.

[scrcpy | github](https://github.com/Genymobile/scrcpy)


## inspeckage (açıklaması blog yazısında mevcut)
kullanmak için öncelikle tcp forward etmeniz gerekli

`adb forward tcp:8008 tcp:8008` komutu ile yapabilirsiniz.

daha sonra uygulamadan bir paket seçip aşağıdaki linki açarsanız aracı kullanabileceksiniz.

`http://127.0.0.1:8008/`



## apktool
bu araç ile apkları decompile edip , tekrar compile edebilirsiniz.
Bu araç uygulamaları smali seviyesine kadar çevirdiği için tekrar compile etmeniz mümkün oluyor, ancak jadx uygulamaları
java seviyesine kadar çevirdiğinden orada tekrar compile mümkün olmuyor.

classes.dex (java dalvik byte code)' u smali seviyesine yükseltiyor

`apktool d <package.apk>` package adında bir klasör oluşturur. her class ın ayrı bir smali dosyası oluşur

`apktool b <klasor> -o output.apk`  `klasor` ü derleyip output.apk yı oluşturur.

Ama apknın imzası kaybolur, kendimiz imzalamamız lazım
[sign.jar](https://github.com/appium/sign/releases)

bu araç ile

`java -jar sign.jar output.apk` komutu ile imzalayabiliriz.


